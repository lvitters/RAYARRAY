/* autogenerated by Processing revision 1283 on 2022-12-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import netP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class RAYARRAY_processing_Dennis extends PApplet {



ArrayList<Node> nodes;
ArrayList<Laser> lasers;

int gridX = 8;
int gridY = 6;
static final int NUM_LASERS = 6;

float absoluteConnectionLength = 45.0f;
float absoluteMirrorWidth = 12.0f;
float scaleCentimetersToPixels = 2.5f;

int recursionGuard = 0;

 public void setup() {
    /* size commented out by preprocessor */;
    frameRate(60);
    rectMode(CENTER);
    surface.setResizable(true);

    nodes = new ArrayList<Node>();
    constructGrid();

    lasers = new ArrayList<Laser>();
    createLasers();
}

 public void draw() {
    background(0);
    lasers.get(0).position().set(new PVector(mouseX, mouseY));
    if (mousePressed) {
        for (Laser l : lasers) {
            l.direction().set(PVector.sub(new PVector(mouseX, mouseY), l.position()).normalize());
        }
    } else {
        lasers.get(0).direction().set(PVector.sub(new PVector(width / 2, height / 2), lasers.get(0).position()).normalize());
    }
    drawNodes();
    drawLasers();
}

//draw each node
 public void drawNodes() {
    for (Node n : nodes) {
        if (keyPressed) {
            n.updateRotation(0.1f * 1.0f/frameRate);
        }
        n.drawJoints();
        n.drawMirror();
    }
}

//draw the rays and their origins
 public void drawLasers() {
    for (Laser l : lasers) {
        l.drawOrigin();
        l.drawRays();
    }
}

//depending on the configuration, construct a grid of nodes in the given pattern
 public void constructGrid() {

    //add one to grid because one will be removed later so the grid looks symmetrical
    gridX += 1;
    gridY += 1;

    //calculate offset between nodes
    float offsetX = (sqrt(2) * absoluteConnectionLength) * scaleCentimetersToPixels;
    float offsetY = offsetX/2;

    //calculate width of the entire grid
    float gridWidth = gridX * offsetX;

    //find position where center of grid will be center of window
    float xPos = (width - gridWidth)/2 + offsetX/2;
    float yPos = (height - gridWidth/2)/2 + offsetY; //TODO: not the middle for some reason?

    //add nodes depending on grid size
    for (int x = 0; x < gridX; x++) {
        for (int y = 0; y < gridY; y++) {
            Node n;
            //offset every second row
            if (y % 2 == 0) {
                //omit last column for symmetry
                if (x != gridX-1) {
                    n = new Node(xPos + (x * offsetX) + offsetX/2, yPos + (y * offsetY));
                    nodes.add(n);
                }
            } else {
                //omit last row for symmetry
                if (y != gridY-1) {
                    n = new Node(xPos + (x * offsetX), yPos + (y * offsetY));
                    nodes.add(n);
                }
            }
        }
    }
}

//for now, add one laser
 public void createLasers() {
    final float mLaserRadius = height * 0.4f;
    for (int i=0; i< NUM_LASERS + 1; i++) {
        Laser l = new Laser();
        lasers.add(l);
        float mPositionRadiant = TWO_PI * (float)i / NUM_LASERS;
        l.position().set(
            width / 2 + sin(mPositionRadiant) * mLaserRadius,
            height / 2 + cos(mPositionRadiant) * mLaserRadius);
        float mRandomDirection = random(TWO_PI);
        l.direction().set(sin(mRandomDirection), cos(mRandomDirection));
    }
}
class Laser {
    Ray mRay;

    Laser() {
        mRay = new Ray();
        position().x = 0;
        position().y = 0;
        direction().x = 1;
        direction().y = 0;
    }

    //set laser diode's position
     public PVector position() {
        return mRay.origin;
    }

     public PVector direction() {
        return mRay.direction;
    }
    
    //draw the origin of the laser diode
     public void drawOrigin() {
        noStroke();
        fill(255);
        circle(position().x, position().y, 10);
    }

    //draw all the rays emitting from that diode
     public void drawRays() {
        mRay.update();
        mRay.draw();
        strokeWeight(1);
        final float mRayLength = 40;
        line(
        position().x,
        position().y,
        position().x + direction().x * mRayLength,
        position().y + direction().y * mRayLength
        );
    }
}
class Node {
    PVector position;
    PVector start = new PVector();
    PVector end = new PVector();
    PVector normal = new PVector();
    final float mirrorRadius = scaleCentimetersToPixels * absoluteMirrorWidth/2 * (sqrt(2)/2);
    final float jointRadius = (scaleCentimetersToPixels * absoluteConnectionLength * (sqrt(2)/2)); //TODO: figure out why it is sqrt(2)/2
    float rotation;
    float rT;

    Node(float x, float y) {
        position = new PVector(x, y);
        rT = random(1000);

        //random initial rotation
        setRotation(random(PI));
    }

    //update the mirrors values
     public void updateRotation(float pDelta) {
        //for now rotate with noise
        rotation += pDelta;
        //rT += random(.001);
        //rotation = radians(map(noise(rT), 0, 1, 0, 360 * 20));
        setRotation(rotation);
    }

    //set start and end point according to rotation
     public void setRotation(float r) {
        rotation = r;
        //apply rotation to beginning and end point of mirror here instead of using rotate() so that the cast() method knows all the absolute points
        start.set(mirrorRadius * sin(r), mirrorRadius * cos(r));
        end.set(-mirrorRadius * sin(r), -mirrorRadius * cos(r));
        normal.set(sin(r - PI/2), cos(r - PI/2)); // rotated by 90Â° or PI/2

        //add position here instead of using translate() so that the cast() function knows all the absolute points
        start.add(position);
        end.add(position);
    }

    //draw line to show the mirrors
     public void drawMirror() {
        strokeWeight(2);
        stroke(255);
        line(start.x, start.y, end.x, end.y);

        /* draw normal */
        strokeWeight(1);
        final float mNormalScale = 10;
        line(
            position.x,
            position.y,
            position.x + normal.x * mNormalScale,
            position.y + normal.y * mNormalScale
            );
    }

    //draw lines to show the joints between the nodes
     public void drawJoints() {
        strokeWeight(3);
        stroke(50);
        pushMatrix();
        {
            translate(position.x, position.y);
            //TODO: figure out how to omit the "outer" joints of the "outer" nodes
            line(jointRadius/2, jointRadius/2, 0, 0);
            line(jointRadius/2, -jointRadius/2, 0, 0);
            line(-jointRadius/2, jointRadius/2, 0, 0);
            line(-jointRadius/2, -jointRadius/2, 0, 0);
        }
        popMatrix();
    }
}
class Ray {
    static final int RECURSION_GUARD_MAX = 100;

    PVector origin = new PVector();
    PVector direction = new PVector();
    PVector hitPoint = null;
    Ray nextRay;

    //update the ray's position
     public void setOrigin(PVector p) {
        origin.set(p);
    }

    //update the ray's direction
     public void setDirection(PVector d) {
        direction.set(d);
    }

    //draw the ray
     public void draw() {
        strokeWeight(2);
        stroke(255, 0, 0);
        if (hitPoint != null) {
            line(
                origin.x,
                origin.y,
                hitPoint.x,
                hitPoint.y
                );
            stroke(255);
            noFill();
            circle(hitPoint.x, hitPoint.y, 10);
        } else {
            stroke(255, 127, 0);
            final float mDefaultLength = 1000;
            line(
                origin.x,
                origin.y,
                origin.x + direction.x * mDefaultLength,
                origin.y + direction.y * mDefaultLength
                );
        }
        strokeWeight(1);
    }

    //draw ray, check for hit with nearest mirror, if there is a hit draw ray to there
    //https://www.youtube.com/watch?v=TOEi6T2mtHo&t=490s&ab_channel=TheCodingTrain
     public void update() {
        PVector closestHit = null;
        float record = Float.MAX_VALUE;
        Node hitNode = null;
        for (Node n : nodes) {
            PVector hit = cast(n);
            if (hit != null) {
                float distance = PVector.dist(origin, hit);
                if (distance < record && distance > n.mirrorRadius * 2) {
                    record = distance;
                    closestHit = hit;
                    hitNode = n;
                }
            }
        }
        if (recursionGuard >=RECURSION_GUARD_MAX ) {
            println("RECURSION_GUARD_MAX");
        }
        if (closestHit != null && hitNode != null && recursionGuard <= RECURSION_GUARD_MAX) {
            recursionGuard++;
            hitPoint = closestHit;
            nextRay = new Ray();
            nextRay.setOrigin(closestHit);

            // DPP
            PVector nextRayDirection = reflect(direction, hitNode.normal);
            nextRay.setDirection(nextRayDirection);

            nextRay.update();
            nextRay.draw();
        } else {
            recursionGuard = 0;
            nextRay = null;
            hitPoint = null;
        }
    }

    //get the direction vector of the reflection (thanks DPP)
     public PVector reflect(PVector pDirection, PVector pNormal) {
        // r = e - 2 (e.n) n :: ( | n | = 1 )
        // with e :: direction
        //      r :: reflection
        //      n :: normal
        PVector n = new PVector().set(pNormal).normalize();
        PVector e = new PVector().set(pDirection);
        float d = PVector.dot(e, n);    // d > 0 = frontface, d < 0 = backface
        n.mult(2 * d);
        PVector r = PVector.sub(e, n);
        return r;
    }

    //determine if it intersects with a mirror
    //https://www.youtube.com/watch?v=TOEi6T2mtHo&t=490s&ab_channel=TheCodingTrain
     public PVector cast(Node node) {
        float x1 = node.start.x;
        float y1 = node.start.y;
        float x2 = node.end.x;
        float y2 = node.end.y;

        float x3 = origin.x;
        float y3 = origin.y;
        float x4 = origin.x + direction.x;
        float y4 = origin.y + direction.y;

        float den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (den == 0) {
            return null; // COINCIDENT || PARALLEL
        }

        float t =   ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
        float u = - ((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

        if (t > 0 && t < 1 && u > 0) {
            PVector pt = new PVector();
            pt.x = x1 + t * (x2 - x1);
            pt.y = y1 + t * (y2 - y1);
            return pt;
        } else {
            return null;
        }
    }
}


  public void settings() { size(1700, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "RAYARRAY_processing_Dennis" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
